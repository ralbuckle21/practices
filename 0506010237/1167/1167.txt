The Buses

Description

A man arrives at a bus stop at 12:00. He remains there during 12:00-12:59. The bus stop is used by a number of bus routes. The man notes the times of arriving buses. The times when buses arrive are given. 

Buses on the same route arrive at regular intervals from 12:00 to 12:59 throughout the entire hour. 

Times are given in whole minutes from 0 to 59. 

Each bus route stops at least 2 times. 

The number of bus routes in the test examples will be <=17. 

Buses from different routes may arrive at the same time. 

Several bus routes can have the same time of first arrival and/or time interval. If two bus routes have the same starting time and interval, they are distinct and are both to be presented. 

Find the schedule with the fewest number of bus routes that must stop at the bus stop to satisfy the input data. For each bus route, output the starting time and the interval. 

Input

Your program is to read from standard input. The input contains a number n (n <= 300) telling how many arriving buses have been noted, followed by the arrival times in ascending order. 
Output

Your program is to write to standard output. The output contains one integer, which is the fewest number of bus routes.
Sample Input

17
0 3 5 13 13 15 21 26 27 29 37 39 39 45 51 52 53
Sample Output

3

Source
#include<cmath>   
#include<iostream>   
#include<cstdio>   
#include<cmath>   
#include<iostream>   
#include<cstdio>   
#include<algorithm>   
#include <vector>   
  
using namespace std;   
  
class Route   
{   
public:   
    Route(int firstTime_, int interval_, int frequence_)    
        : firstTime(firstTime_)   
        , interval(interval_)   
        , frequence(frequence_)   
    {   
    }   
    bool operator <(const Route &lhs) const  
    {   
        return frequence > lhs.frequence;   
    }   
    int firstTime;   
    int interval;   
    int frequence;   
};   
  
int visited[60] = { 0 };   
std::vector <Route> routes;   
  
//firstTime < interval, otherwise firstTime - interval earlier than firstTime (1)   
//firstTime + interval <= 59 =>  interval <= 59 - firstTime (2)   
//(1)(2)==> firstTime < interval <= 59 - firstTime => 2*firstTime < interval => firstTime <= 29 (3)   
//firstTime >= 0   
// => 0 <= firstTime <= 29, 1 <= interval <= 59    (4)   
// first + frequency * interval > 59  => frequency > (59 - first) / interval   
// first + (frequency - 1) * interval <= 59 => frequency <= (59 - first) / interval + 1   
// => frequency = (59 - first) / interval + 1 (4)   
void prepareRoutes()   
{   
    routes.reserve(900);   
    for (int firstTime = 0; firstTime <= 29; ++firstTime)   
    {   
        if (!visited[firstTime])   
            continue;   
        for (int interval = firstTime + 1; interval <= 59 - firstTime; ++interval)   
        {   
            bool suffice = true;   
            for (int k = firstTime + interval; k <= 59; k += interval)   
            {   
                if (!visited[k])   
                {   
                    suffice = false;   
                    break;   
                }   
            }   
            if (suffice)   
            {   
                int fre = 1 + (59 - firstTime) / interval;   
                routes.push_back(Route(firstTime, interval, fre));   
            }   
        }   
    }   
    sort(routes.begin(), routes.end());   
}//prepareRoutes   
  
int nMinRoutes = 17;   
  
bool isValidRoute(int firstTime, int interval)   
{   
    int t = firstTime;   
    for (; t <= 59; t += interval)   
    {   
        if (!visited[t])   
            return false;   
    }   
    return true;   
}   
  
//std::vector <Route> bestX;   
//std::vector <Route> currentX;   
  
//在搜索时，如果还有n个未被覆盖，用频率为f的线路来覆盖，至少需要n/f条，显然f>n的线路是不可能符合条件的   
void solve(int currentRouteNumber, int nCurrentRoutes, int nRemain)   
{   
    if (nRemain == 0)   
    {   
        if (nCurrentRoutes < nMinRoutes)   
        {   
            nMinRoutes = nCurrentRoutes;   
            //bestX = currentX;   
        }   
        //else   
        //{   
        //  currentX.clear();   
        //}   
        return;   
    }   
    while (currentRouteNumber < (int)routes.size() && routes[currentRouteNumber].frequence > nRemain)   
        ++currentRouteNumber;   
    for (;currentRouteNumber < (int)routes.size(); ++currentRouteNumber)   
    {   
        if (nCurrentRoutes + 1 + (nRemain - 1) / routes[currentRouteNumber].frequence >= nMinRoutes)   
            return;   
  
        if (isValidRoute(routes[currentRouteNumber].firstTime, routes[currentRouteNumber].interval))   
        {   
            //currentX.push_back(routes[currentRouteNumber]);   
  
            for (int i = routes[currentRouteNumber].firstTime; i <= 59; i += routes[currentRouteNumber].interval)   
            {   
                    --visited[i];   
                    --nRemain;   
            }   
            solve(currentRouteNumber, nCurrentRoutes + 1, nRemain);//线路不同的公交路线可能有相同的起始时间和间隔   
            for (int i = routes[currentRouteNumber].firstTime; i <= 59; i += routes[currentRouteNumber].interval)   
            {   
                ++visited[i];   
                ++nRemain;   
            }   
            //currentX.pop_back();   
        }   
    }   
}   
  
int main()   
{   
    int n;   
    scanf ("%d", &n);   
  
    int tmp;   
    for (int i = 0; i < n; ++i)   
    {   
        scanf("%d", &tmp);   
        visited[tmp]++;   
    }   
    prepareRoutes();   
    solve(0, 0, n);   
    printf("%d\n", nMinRoutes);  
    return 0;   
}
