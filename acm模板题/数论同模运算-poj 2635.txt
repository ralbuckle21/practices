/*The Embarrassed Cryptographer同模运算
The young and very promising cryptographer Odd Even has implemented the security module of a large system with thousands of users, which is now in use in his company. The cryptographic keys are created from the product of two primes, and are believed to be secure because there is no known method for factoring such a product effectively. 
What Odd Even did not think of, was that both factors in a key should be large, not just their product. It is now possible that some of the users of the system have weak keys. In a desperate attempt not to be fired, Odd Even secretly goes through all the users keys, to check if they are strong enough. He uses his very poweful Atari, and is especially careful when checking his boss' key.
Input

The input consists of no more than 20 test cases. Each test case is a line with the integers 4 <= K <= 10100 and 2 <= L <= 106. K is the key itself, a product of two primes. L is the wanted minimum size of the factors in the key. The input set is terminated by a case where K = 0 and L = 0.
Output

For each number K, if one of its factors are strictly less than the required L, your program should output "BAD p", where p is the smallest factor in K. Otherwise, it should output "GOOD". Cases should be separated by a line-break.
Sample Input

143 10
143 20
667 20
667 30
2573 30
2573 40
0 0
Sample Output

GOOD
BAD 11
GOOD
BAD 23
GOOD
BAD 31
想求123%4，可以这么操作
(100%4+20%4+3%4)%4。利用了性质1、性质3。
为何把它化作千进制，因为利用性质三，可知其是正确的。化作千进制，求模就变成了不超过1000的数的模，虽然次数增多，但是可以求解大数的模。
*/
#include <iostream>
#include <string>
#include <math.h>

using namespace std;

#define Max 1000000 + 100

bool prime[Max];
int p[100000];

int IsPrime()
{
	prime[0] = prime[1] = 0;
	prime[2] = 1;
	for (int i = 3; i < Max; i++)
	{
		prime[i] = i % 2 == 0 ? 0 : 1;
	}
	int t = (int) sqrt(Max*1.0);
	for (int i = 3; i <= t; i++)
	{
		if (prime[i])
		{
			for (int j = i * 2; j < Max; j += i)
			{
				prime[j] = 0;
			}
		}
	}

	int j = 1;
	for (int k = 0; k < Max; k++)
	{
		if (prime[k])
		{
			p[j++] = k;
		}
	}
	return j;
}

bool mod(const int* K, const int p, const int len)
{
	int sq = 0;
	for (int i = len - 1; i >= 0; i--)
		sq = (sq * 1000 + K[i])%p; 

	if (!sq)   //K被整除  
		return false;
	return true;
}

int main()
{
	int num_of_prime = IsPrime();

	int num[100];
	string s;
	int l;
	while (cin >> s >> l && l)
	{
		memset(num, 0, sizeof(num));
		for (int i = 0; i < s.size(); i++)//局部顺序，全局倒序  
		{
			
			int pKt = (s.size() + 2 - i) / 3 - 1;
			num[pKt] = num[pKt] * 10 + (s[i] - '0');
		}

		int length_of_num = (s.size() + 2) / 3;

		bool flag = true;

		for (int i = 1; p[i] < l; ++i)
		{
			if (!mod(num, p[i], length_of_num))
			{
				flag = false;
				cout << "BAD " << p[i] << endl;
				break;
			}
		}
		if (flag)
			cout << "GOOD" << endl;

	}
}